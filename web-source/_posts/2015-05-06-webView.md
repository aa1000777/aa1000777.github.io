---
layout: post
title: 完美解决 Android WebView 文本框获取焦点后自动放大问题  
categories: [All,Android]
tags: [Android,QrCode]
fullview: false
description: 前几天在写一个项目时，要求在项目中嵌入一个WebView 本来很快就完成了，测试也没有问题。但发给新加坡时，他们测试都会出现文本框聚焦时，网页面会放大（他们用三星手机测试的）
---
网上查了好久参考他的方法加上去测试 [http://www.cppblog.com/guojingjia2006/archive/2012/12/18/196429.html](http://www.cppblog.com/guojingjia2006/archive/2012/12/18/196429.html "http://www.cppblog.com/guojingjia2006/archive/2012/12/18/196429.html")

下面我将原文copy过来

***

不同android 版本的webview底层实现有差异
今天弄了下android webview下的几个页面。原先以为android 4+把 webview的viewport属性忽略掉了。
但是今天弄了下。加了个 authorizationView.getSettings().setUseWideViewPort(true);
viewport 的几个属性重新起作用。(测试环境，4.0+的几个版本）

但是又遇到几个问题，就是html里有input的时候。获取焦点的时候，android会重新缩放到原来模式,看源码：
 
{% highlight java %}

    	/** 
          * Called in response to a message from webkit telling us that the soft 
          * keyboard should be launched. 
         */  
        private void displaySoftKeyboard(boolean isTextView) {  
            InputMethodManager imm = (InputMethodManager)  
                    getContext().getSystemService(Context.INPUT_METHOD_SERVICE);  
      
            // bring it back to the default level scale so that user can enter text  
            boolean zoom = mZoomManager.getScale() < mZoomManager.getDefaultScale();  
            if (zoom) {  
                mZoomManager.setZoomCenter(mLastTouchX, mLastTouchY);  
                mZoomManager.setZoomScale(mZoomManager.getDefaultScale(), false);  
            }  
            if (isTextView) {  
                rebuildWebTextView();  
                if (inEditingMode()) {  
                    imm.showSoftInput(mWebTextView, 0, mWebTextView.getResultReceiver());  
                    if (zoom) {  
                        didUpdateWebTextViewDimensions(INTERSECTS_SCREEN);  
                    }  
                    return;  
                }  
            }  
            // Used by plugins and contentEditable.  
            // Also used if the navigation cache is out of date, and  
            // does not recognize that a textfield is in focus.  In that  
            // case, use WebView as the targeted view.  
            // see http://b/issue?id=2457459  
            imm.showSoftInput(this, 0);  
        }  

{% endhighlight %}

从源码可以看到，webview当要弹起键盘的时候，会判定当前的缩放比例与默认大小（我测试了下，我自己的版本的默认值是1.5),
当你网页viewport设置initial-scale=0.5时，当input 获取焦点的时候，android会放大到原来模式，不是我们想要的，网上查了下相关，
有个解决方案： 



{% highlight java %}

	wv.setOnFocusChangeListener(new View.OnFocusChangeListener() {  
        @Override  
        public void onFocusChange(View v, boolean hasFocus) {  
            // TODO Auto-generated method stub  
            try {  
                Field defaultScale = WebView.class  
                        .getDeclaredField("mDefaultScale");  
                defaultScale.setAccessible(true);  
                float _s = defaultScale.getFloat(wv);  
                defaultScale.setFloat(wv, scale);  
                float x = wv.getScale();  
                int i = 0;  
            } catch (Exception e) {  
                e.printStackTrace();  
                try {  
                    Field defaultZoom = WebView.class  
                            .getDeclaredField("mZoomManager");  
                    defaultZoom.setAccessible(true);  
                    Field defaultScale = defaultZoom.getType()  
                            .getDeclaredField("mDefaultScale");  
                    defaultScale.setAccessible(true);  
                    defaultScale.setFloat(defaultZoom.get(wv), scale);  
                } catch (Exception ee) {  
                    ee.printStackTrace();  
                }  
            }  
        }  
    }); 

{% endhighlight %}

但是作者碰到另外一个问题，引用自原话： 

{% highlight yaml %}

    as it showed, I using reflect to find the field 'mDefaultScale' to control the WebView.  
    But it doesn't work on Android 4.1.1 (Google Nexus), and I catch an exception —— java.lang.NoSuchFieldException: mDefaultScale.  
    Then I list the fileds and found the framework source seems being changed(I can only reach a field called 'mProvider').  
      
    So how can I fix the problem (I haven't got the source yet)? Thanks for reading my question with my poor English, Thx :)  
      
    PS: maybe a online framework source review website is helpful but I can't found one, if you can provide me one, it will be great. :P  

{% endhighlight %}

完了我自己测试了，发现此方案解决不了。但是引出了另外一问题，就是不用android版本下的webview实现是不一样的，其实看代码就能看出，
原先webview有mDefaultScale字段，但是后来应该挪到mZoomManager里去了，但是我发现我手机上webview 实现和作者遇到的问题一样，只有mProvider成员，
没有mZoomManager,所以只能寻求源码，千辛万苦，终于找到
[http://androidxref.com/4.2_r1/xref/frameworks/base/core/java/android/webkit/WebViewClassic.java](http://androidxref.com/4.2_r1/xref/frameworks/base/core/java/android/webkit/WebViewClassic.java "http://androidxref.com/4.2_r1/xref/frameworks/base/core/java/android/webkit/WebViewClassic.java")，
mProvider 其实类型就是WebViewClassic(自己看下源码实现）,简要提下，WebProvider只是一个接口，作为WebView的一个成员，
创建时用了factory来，完了看下几个工厂类，最后是webviewclassic实例)。
 对于Jerry Bean 4.2这个版本（我一个手机就是自己刷的rom)，webview的实现又换了个，所以要拿到默认缩放的成员，如下: 

{% highlight java %}

    try {    
                        Field defaultScale = WebView.class    
                                .getDeclaredField("mDefaultScale");    
                        defaultScale.setAccessible(true);    
                        float sv = defaultScale.getFloat(authorizationView);  
                        defaultScale.setFloat(authorizationView, xxx);    
                    } catch (SecurityException e) {    
                        e.printStackTrace();    
                    } catch (IllegalArgumentException e) {    
                        e.printStackTrace();    
                    } catch (IllegalAccessException e) {    
                        e.printStackTrace();    
                    } catch (NoSuchFieldException e) {    
                        e.printStackTrace();    
                        try {    
                            Field zoomManager;     
                            zoomManager = WebView.class.getDeclaredField("mZoomManager");    
                            zoomManager.setAccessible(true);    
                            Object zoomValue = zoomManager.get(authorizationView);    
                            Field defaultScale = zoomManager.getType().getDeclaredField("mDefaultScale");    
                            defaultScale.setAccessible(true);    
                            float sv = defaultScale.getFloat(zoomValue);  
                            defaultScale.setFloat(zoomValue, xxx);    
                        } catch (SecurityException e1) {    
                            e1.printStackTrace();    
                        } catch (IllegalArgumentException e1) {    
                            e.printStackTrace();    
                        } catch (IllegalAccessException e1) {    
                            e.printStackTrace();    
                        } catch (NoSuchFieldException e1) {    
                            e1.printStackTrace();    
                              
                            try {  
                                Field mProviderField = WebView.class.getDeclaredField("mProvider");    
                                mProviderField.setAccessible(true);  
                                //mProviderField.getClass()  
                                Object webviewclassic = mProviderField.get(authorizationView);    
                                  
                                Field zoomManager = webviewclassic.getClass().getDeclaredField("mZoomManager");     
                                zoomManager.setAccessible(true);  
                                Object zoomValue = zoomManager.get(webviewclassic);    
                                Field defaultScale = zoomManager.getType().getDeclaredField("mDefaultScale");    
                                defaultScale.setAccessible(true);    
                                float sv = defaultScale.getFloat(zoomValue);  
                                defaultScale.setFloat(zoomValue, xxx);    
                            }catch(Exception e2)  
                            {  
                                e2.printStackTrace();  
                            }  
                        }    
                    }  

{% endhighlight %}


虽然可以拿到，并且设置成功，但是在我的手机上还是不能解决input 获取焦点后自动放大，
完了想了下，有个实现模式可以参考:当input 获取焦点时，js调用java设置默认放缩率，设置前保存原有值，失去焦点后重新设置原来值，不然跳转到其他页面的时候，你会发现比例不对了。:)。

因为放大后双击还是还原回原来样子。所以暂且不来纠结这个东西了。因为不同android版本的如果webview实现不一致的话，这代码就不起作用了 ：）

****


按大神的方法测试只有在三星手机找不到 mZoomManager 这个类 所以方法还是行不通

后来又找到TV端Android WebView 文本框获取焦点后自动放大的问题（代码我就只copy部分过来了）

---

最后经过多次尝试最后找的解决办法就是：在webview.setWebChromeClient中重写onProgressChanged方法，加入view.requestFocus();就可以让文本框得到焦点后弹出键盘，同时页面也不会被放大；

针对TV端的 webview中的网页设定，可以参考一下代码

{% highlight java %}

    mWebView.setWebChromeClient(new WebChromeClient()  
    {  
      
            @Override  
            public void onProgressChanged(WebView view, int newProgress)  
            {  
                    // TODO Auto-generated method stub  
                    super.onProgressChanged(view, newProgress);  
                    view.requestFocus();  
      
            }  
      
     });  

{% endhighlight %}


重载onProgressChanged方法之后，页面缩放的问题解决了，键盘调用也正常了。

——————————————————————————————————————————————————————————————————————

我加到我的代码中，发现在手机中的确有效果，但发到新加坡，得到的回复，还是同样的问题！

到此，我表示我很伤心很伤心

想想，只能用js去处理了

正当我伤心写着demo时，我老大下班了，问我走不走。我就跟他讲了我的问题。他果断去开机去了，说试试他那边能不能改（我老大是写后台端的）

`问题解决了，只加了以下两句代码---------------蛋蛋的优伤`

{% highlight html %}

    <!-- 下面两句代码是做手机适配用的 ， 加上之后手机网页就会自动适配-->  
    <meta name="viewport" content="width=device-width">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">   

{% endhighlight %}

哦，不好意思忘了上demo了

Demo：[WebViewAdapter](git.oschina.net/aa1000777/WebViewAdapter "git.oschina.net/aa1000777/WebViewAdapter")